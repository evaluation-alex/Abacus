/**
*
*   Abacus
*   A combinatorics library for Node/JS, PHP, Python
*   @version: 0.1
*   https://github.com/foo123/Abacus
**/
!function( root, name, factory ) {
"use strict";
// export the module, umd-style (no other dependencies)
var isCommonJS = ("object" === typeof(module)) && module.exports, 
    isAMD = ("function" === typeof(define)) && define.amd, m;

// CommonJS, node, etc..
if ( isCommonJS ) 
    module.exports = (module.$deps = module.$deps || {})[ name ] = module.$deps[ name ] || (factory.call( root, {NODE:module} ) || 1);

// AMD, requireJS, etc..
else if ( isAMD && ("function" === typeof(require)) && ("function" === typeof(require.specified)) && require.specified(name) ) 
    define( name, ['require', 'exports', 'module'], function( require, exports, module ){ return factory.call( root, {AMD:module} ); } );

// browser, web worker, etc.. + AMD, other loaders
else if ( !(name in root) ) 
    (root[ name ] = (m=factory.call( root, {} ) || 1)) && isAMD && define( name, [], function( ){ return m; } );
}(  /* current root */          this, 
    /* module name */           "Abacus",
    /* module factory */        function( exports, undef ) {
"use strict";

var PROTO = 'prototype', HAS = 'hasOwnProperty', Extend = Object.create
    ,Merge = function(a, b) {
        for (var p in b) 
            if (b[HAS](p)) a[p] = b[p];
        return a;
    }
    ,Class = function(s, c) {
        if ( 1 === arguments.length )
        {
            c = s;
            s = Object;
        }
        var ctor = c.constructor;
        if ( c[HAS]('__static__') )
        {
            ctor = Merge(ctor, c.__static__);
            delete c.__static__;
        }
        ctor[PROTO] = Merge(Extend(s[PROTO]), c);
        return ctor;
    }
    // http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogLookup
    // compute binary bitwise logarithm, using BINLOG lookup table + binary-search (a variation of dynamic programming)
    ,ArrayUint8 = 'undefined' !== typeof Uint8Array ? Uint8Array : Array
    // pre-computed lookup tables for binary log, factorial and binomial
    ,BINLOG_256 = new ArrayUint8([0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7])
    ,FACT_N_4_68 = [24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87178291200,1307674368000,20922789888000,355687428096001,6402373705727948,121645100408832080,2432902008176640000,51090942171709420000,1.1240007277776035e+21,2.5852016738884878e+22,6.204484017332391e+23,1.5511210043330954e+25,4.032914611266054e+26,1.0888869450418268e+28,3.0488834461171542e+29,8.841761993739751e+30,2.6525285981219316e+32,8.22283865417801e+33,2.631308369336913e+35,8.683317618811995e+36,2.952327990396092e+38,1.0333147966386149e+40,3.71993326789901e+41,1.3763753091226355e+43,5.230226174665922e+44,2.039788208119776e+46,8.159152832479056e+47,3.3452526613164405e+49,1.405006117752897e+51,6.041526306337411e+52,2.658271574788457e+54,1.1962222086548374e+56,5.502622159812145e+57,2.5862324151116456e+59,1.2413915592536315e+61,6.082818640342558e+62,3.041409320171302e+64,1.5511187532874088e+66,8.065817517094494e+67,4.274883284060001e+69,2.308436973392454e+71,1.2696403353658287e+73,7.109985878048745e+74,4.052691950487695e+76,2.3505613312828353e+78,1.3868311854568818e+80,8.320987112741444e+81,5.075802138772222e+83,3.146997326038748e+85,1.9826083154044198e+87,1.2688693218588067e+89,8.247650592082321e+90,5.443449390774147e+92,3.647111091818739e+94]    
    ,BINOM_N_K_3_67 = [3,6,4,10,10,5,15,20,15,6,21,35,35,21,7,28,56,70,56,28,8,36,84,126,126,84,36,9,45,120,210,252,210,120,45,10,55,165,330,462,462,330,165,55,11,66,220,495,792,924,792,495,220,66,12,78,286,715,1287,1716,1716,1287,715,286,78,13,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504,4845,1140,190,20,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264,20349,5985,1330,210,21,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544,74613,26334,7315,1540,231,22,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314,245157,100947,33649,8855,1771,253,23,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504,735471,346104,134596,42504,10626,2024,276,24,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760,2042975,1081575,480700,177100,53130,12650,2300,300,25,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160,5311735,3124550,1562275,657800,230230,65780,14950,2600,325,26,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860,13037895,8436285,4686825,2220075,888030,296010,80730,17550,2925,351,27,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160,30421755,21474180,13123110,6906900,3108105,1184040,376740,98280,20475,3276,378,28,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760,67863915,51895935,34597290,20030010,10015005,4292145,1560780,475020,118755,23751,3654,406,29,435,4060,27405,142506,593775,2035800,5852925,14307150,30045015,54627300,86493225,119759850,145422675,155117520,145422675,119759850,86493225,54627300,30045015,14307150,5852925,2035800,593775,142506,27405,4060,435,30,465,4495,31465,169911,736281,2629575,7888725,20160075,44352165,84672315,141120525,206253075,265182525,300540195,300540195,265182525,206253075,141120525,84672315,44352165,20160075,7888725,2629575,736281,169911,31465,4495,465,31,496,4960,35960,201376,906192,3365856,10518300,28048800,64512240,129024480,225792840,347373600,471435600,565722720,601080390,565722720,471435600,347373600,225792840,129024480,64512240,28048800,10518300,3365856,906192,201376,35960,4960,496,32,528,5456,40920,237336,1107568,4272048,13884156,38567100,92561040,193536720,354817320,573166440,818809200,1037158320,1166803110,1166803110,1037158320,818809200,573166440,354817320,193536720,92561040,38567100,13884156,4272048,1107568,237336,40920,5456,528,33,561,5984,46376,278256,1344904,5379616,18156204,52451256,131128140,286097760,548354040,927983760,1391975640,1855967520,2203961430,2333606220,2203961430,1855967520,1391975640,927983760,548354040,286097760,131128140,52451256,18156204,5379616,1344904,278256,46376,5984,561,34,595,6545,52360,324632,1623160,6724520,23535820,70607460,183579396,417225900,834451800,1476337800,2319959400,3247943160,4059928950,4537567650,4537567650,4059928950,3247943160,2319959400,1476337800,834451800,417225900,183579396,70607460,23535820,6724520,1623160,324632,52360,6545,595,35,630,7140,58905,376992,1947792,8347680,30260340,94143280,254186856,600805296,1251677700,2310789600,3796297200,5567902560,7307872110,8597496600,9075135300,8597496600,7307872110,5567902560,3796297200,2310789600,1251677700,600805296,254186856,94143280,30260340,8347680,1947792,376992,58905,7140,630,36,666,7770,66045,435897,2324784,10295472,38608020,124403620,348330136,854992152,1852482996,3562467300,6107086800,9364199760,12875774670,15905368710,17672631900,17672631900,15905368710,12875774670,9364199760,6107086800,3562467300,1852482996,854992152,348330136,124403620,38608020,10295472,2324784,435897,66045,7770,666,37,703,8436,73815,501942,2760681,12620256,48903492,163011640,472733756,1203322288,2707475148,5414950296,9669554100,15471286560,22239974430,28781143380,33578000610,35345263800,33578000610,28781143380,22239974430,15471286560,9669554100,5414950296,2707475148,1203322288,472733756,163011640,48903492,12620256,2760681,501942,73815,8436,703,38,741,9139,82251,575757,3262623,15380937,61523748,211915132,635745396,1676056044,3910797436,8122425444,15084504396,25140840660,37711260990,51021117810,62359143990,68923264410,68923264410,62359143990,51021117810,37711260990,25140840660,15084504396,8122425444,3910797436,1676056044,635745396,211915132,61523748,15380937,3262623,575757,82251,9139,741,39,780,9880,91390,658008,3838380,18643560,76904685,273438880,847660528,2311801440,5586853480,12033222880,23206929840,40225345056,62852101650,88732378800,113380261800,131282408400,137846528820,131282408400,113380261800,88732378800,62852101650,40225345056,23206929840,12033222880,5586853480,2311801440,847660528,273438880,76904685,18643560,3838380,658008,91390,9880,780,40,820,10660,101270,749398,4496388,22481940,95548245,350343565,1121099408,3159461968,7898654920,17620076360,35240152720,63432274896,103077446706,151584480450,202112640600,244662670200,269128937220,269128937220,244662670200,202112640600,151584480450,103077446706,63432274896,35240152720,17620076360,7898654920,3159461968,1121099408,350343565,95548245,22481940,4496388,749398,101270,10660,820,41,861,11480,111930,850668,5245786,26978328,118030185,445891810,1471442973,4280561376,11058116888,25518731280,52860229080,98672427616,166509721602,254661927156,353697121050,446775310800,513791607420,538257874440,513791607420,446775310800,353697121050,254661927156,166509721602,98672427616,52860229080,25518731280,11058116888,4280561376,1471442973,445891810,118030185,26978328,5245786,850668,111930,11480,861,42,903,12341,123410,962598,6096454,32224114,145008513,563921995,1917334783,5752004349,15338678264,36576848168,78378960360,151532656696,265182149218,421171648758,608359048206,800472431850,960566918220,1052049481860,1052049481860,960566918220,800472431850,608359048206,421171648758,265182149218,151532656696,78378960360,36576848168,15338678264,5752004349,1917334783,563921995,145008513,32224114,6096454,962598,123410,12341,903,43,946,13244,135751,1086008,7059052,38320568,177232627,708930508,2481256778,7669339132,21090682613,51915526432,114955808528,229911617056,416714805914,686353797976,1029530696964,1408831480056,1761039350070,2012616400080,2104098963720,2012616400080,1761039350070,1408831480056,1029530696964,686353797976,416714805914,229911617056,114955808528,51915526432,21090682613,7669339132,2481256778,708930508,177232627,38320568,7059052,1086008,135751,13244,946,44,990,14190,148995,1221759,8145060,45379620,215553195,886163135,3190187286,10150595910,28760021745,73006209045,166871334960,344867425584,646626422970,1103068603890,1715884494940,2438362177020,3169870830126,3773655750150,4116715363800,4116715363800,3773655750150,3169870830126,2438362177020,1715884494940,1103068603890,646626422970,344867425584,166871334960,73006209045,28760021745,10150595910,3190187286,886163135,215553195,45379620,8145060,1221759,148995,14190,990,45,1035,15180,163185,1370754,9366819,53524680,260932815,1101716330,4076350421,13340783196,38910617655,101766230790,239877544005,511738760544,991493848554,1749695026860,2818953098830,4154246671960,5608233007146,6943526580276,7890371113950,8233430727600,7890371113950,6943526580276,5608233007146,4154246671960,2818953098830,1749695026860,991493848554,511738760544,239877544005,101766230790,38910617655,13340783196,4076350421,1101716330,260932815,53524680,9366819,1370754,163185,15180,1035,46,1081,16215,178365,1533939,10737573,62891499,314457495,1362649145,5178066751,17417133617,52251400851,140676848445,341643774795,751616304549,1503232609098,2741188875414,4568648125690,6973199770790,9762479679106,12551759587422,14833897694226,16123801841550,16123801841550,14833897694226,12551759587422,9762479679106,6973199770790,4568648125690,2741188875414,1503232609098,751616304549,341643774795,140676848445,52251400851,17417133617,5178066751,1362649145,314457495,62891499,10737573,1533939,178365,16215,1081,47,1128,17296,194580,1712304,12271512,73629072,377348994,1677106640,6540715896,22595200368,69668534468,192928249296,482320623240,1093260079344,2254848913647,4244421484512,7309837001104,11541847896480,16735679449896,22314239266528,27385657281648,30957699535776,32247603683100,30957699535776,27385657281648,22314239266528,16735679449896,11541847896480,7309837001104,4244421484512,2254848913647,1093260079344,482320623240,192928249296,69668534468,22595200368,6540715896,1677106640,377348994,73629072,12271512,1712304,194580,17296,1128,48,1176,18424,211876,1906884,13983816,85900584,450978066,2054455634,8217822536,29135916264,92263734836,262596783764,675248872536,1575580702584,3348108992991,6499270398159,11554258485616,18851684897584,28277527346376,39049918716424,49699896548176,58343356817424,63205303218876,63205303218876,58343356817424,49699896548176,39049918716424,28277527346376,18851684897584,11554258485616,6499270398159,3348108992991,1575580702584,675248872536,262596783764,92263734836,29135916264,8217822536,2054455634,450978066,85900584,13983816,1906884,211876,18424,1176,49,1225,19600,230300,2118760,15890700,99884400,536878650,2505433700,10272278170,37353738800,121399651100,354860518600,937845656300,2250829575120,4923689695575,9847379391150,18053528883775,30405943383200,47129212243960,67327446062800,88749815264600,108043253365600,121548660036300,126410606437753,121548660036300,108043253365600,88749815264600,67327446062800,47129212243960,30405943383200,18053528883775,9847379391150,4923689695575,2250829575120,937845656300,354860518600,121399651100,37353738800,10272278170,2505433700,536878650,99884400,15890700,2118760,230300,19600,1225,50,1275,20825,249900,2349060,18009460,115775100,636763050,3042312350,12777711870,47626016970,158753389900,476260169700,1292706174900,3188675231420,7174519270695,14771069086725,27900908274925,48459472266975,77535155627160,114456658306760,156077261327400,196793068630200,229591913401899,247959266474052,247959266474052,229591913401899,196793068630200,156077261327400,114456658306760,77535155627160,48459472266975,27900908274925,14771069086725,7174519270695,3188675231420,1292706174900,476260169700,158753389900,47626016970,12777711870,3042312350,636763050,115775100,18009460,2349060,249900,20825,1275,51,1326,22100,270725,2598960,20358520,133784560,752538150,3679075400,15820024220,60403728840,206379406870,635013559600,1768966344600,4481381406320,10363194502115,21945588357420,42671977361650,76360380541901,125994627894134,191991813933921,270533919634161,352870329957602,426384982032101,477551179875953,495918532948104,477551179875953,426384982032101,352870329957602,270533919634161,191991813933921,125994627894134,76360380541901,42671977361650,21945588357420,10363194502115,4481381406320,1768966344600,635013559600,206379406870,60403728840,15820024220,3679075400,752538150,133784560,20358520,2598960,270725,22100,1326,52,1378,23426,292825,2869685,22957480,154143080,886322710,4431613550,19499099620,76223753060,266783135710,841392966470,2403979904200,6250347750920,14844575908435,32308782859535,64617565719070,119032357903550,202355008436036,317986441828054,462525733568081,623404249591763,779255311989703,903936161908051,973469712824052,973469712824052,903936161908051,779255311989703,623404249591763,462525733568081,317986441828054,202355008436036,119032357903550,64617565719070,32308782859535,14844575908435,6250347750920,2403979904200,841392966470,266783135710,76223753060,19499099620,4431613550,886322710,154143080,22957480,2869685,292825,23426,1378,53,1431,24804,316251,3162510,25827165,177100560,1040465790,5317936260,23930713170,95722852680,343006888770,1108176102180,3245372870670,8654327655120,21094923659355,47153358767970,96926348578605,183649923622620,321387366339585,520341450264093,780512175396131,1085929983159844,1402659561581464,1683191473897764,1877405874732106,1946939425648107,1877405874732106,1683191473897764,1402659561581464,1085929983159844,780512175396131,520341450264093,321387366339585,183649923622620,96926348578605,47153358767970,21094923659355,8654327655120,3245372870670,1108176102180,343006888770,95722852680,23930713170,5317936260,1040465790,177100560,25827165,3162510,316251,24804,1431,54,1485,26235,341055,3478761,28989675,202927725,1217566350,6358402050,29248649430,119653565850,438729741450,1451182990950,4353548972850,11899700525790,29749251314475,68248282427325,144079707346575,280576272201225,505037289962205,841728816603674,1300853625660224,1866442158555973,2488589544741313,3085851035479219,3560597348629871,3824345300380233,3824345300380233,3560597348629871,3085851035479219,2488589544741313,1866442158555973,1300853625660224,841728816603674,505037289962205,280576272201225,144079707346575,68248282427325,29749251314475,11899700525790,4353548972850,1451182990950,438729741450,119653565850,29248649430,6358402050,1217566350,202927725,28989675,3478761,341055,26235,1485,55,1540,27720,367290,3819816,32468436,231917400,1420494075,7575968400,35607051480,148902215280,558383307300,1889912732400,5804731963800,16253249498640,41648951840265,97997533741800,212327989773900,424655979547800,785613562163431,1346766106565882,2142582442263905,3167295784216199,4355031703297258,5574440580220550,6646448384109080,7384942649010104,7648690600760426,7384942649010104,6646448384109080,5574440580220550,4355031703297258,3167295784216199,2142582442263905,1346766106565882,785613562163431,424655979547800,212327989773900,97997533741800,41648951840265,16253249498640,5804731963800,1889912732400,558383307300,148902215280,35607051480,7575968400,1420494075,231917400,32468436,3819816,367290,27720,1540,56,1596,29260,395010,4187106,36288252,264385836,1652411475,8996462475,43183019880,184509266760,707285522580,2448296039700,7694644696200,22057981462440,57902201338905,139646485582064,310325523515700,636983969321702,1210269541711230,2132379668729313,3489348548829794,5309878226480108,7522327487513496,9929472283517756,12220888964329642,14031391033119156,15033633249770580,15033633249770580,14031391033119156,12220888964329642,9929472283517756,7522327487513496,5309878226480108,3489348548829794,2132379668729313,1210269541711230,636983969321702,310325523515700,139646485582064,57902201338905,22057981462440,7694644696200,2448296039700,707285522580,184509266760,43183019880,8996462475,1652411475,264385836,36288252,4187106,395010,29260,1596,57,1653,30856,424270,4582116,40475358,300674088,1916797311,10648873950,52179482355,227692286640,891794789340,3155581562280,10142940735900,29752626158640,79960182801345,197548686920971,449972009097766,947309492837394,1847253511032928,3342649210440549,5621728217559092,8799226775309874,12832205713993584,17451799771031256,22150361247847324,26252279997448920,29065024282889790,30067266499541216,29065024282889790,26252279997448920,22150361247847324,17451799771031256,12832205713993584,8799226775309874,5621728217559092,3342649210440549,1847253511032928,947309492837394,449972009097766,197548686920971,79960182801345,29752626158640,10142940735900,3155581562280,891794789340,227692286640,52179482355,10648873950,1916797311,300674088,40475358,4582116,424270,30856,1653,58,1711,32509,455126,5006386,45057474,341149446,2217471399,12565671261,62828356305,279871768995,1119487075980,4047376351620,13298522298180,39895566894540,109712808959985,277508869722316,647520696018735,1397281501935164,2794563003870313,5189902721473464,8964377427999614,14420954992868962,21631432489303508,30284005485024884,39602161018878536,48402641245295970,55317304280338450,59132290782430890,59132290782430890,55317304280338450,48402641245295970,39602161018878536,30284005485024884,21631432489303508,14420954992868962,8964377427999614,5189902721473464,2794563003870313,1397281501935164,647520696018735,277508869722316,109712808959985,39895566894540,13298522298180,4047376351620,1119487075980,279871768995,62828356305,12565671261,2217471399,341149446,45057474,5006386,455126,32509,1711,59,1770,34220,487635,5461512,50063860,386206920,2558620845,14783142660,75394027566,342700125300,1399358844975,5166863427600,17345898649800,53194089192720,149608375854526,387221678682300,925029565741052,2044802197953905,4191844505805482,7984465725343788,14154280149473086,23385332420868824,36052387482172440,51915437974328344,69886166503903770,88004802264174900,103719945525634800,114449595062769620,118264581564861980,114449595062769620,103719945525634800,88004802264174900,69886166503903770,51915437974328344,36052387482172440,23385332420868824,14154280149473086,7984465725343788,4191844505805482,2044802197953905,925029565741052,387221678682300,149608375854526,53194089192720,17345898649800,5166863427600,1399358844975,342700125300,75394027566,14783142660,2558620845,386206920,50063860,5461512,487635,34220,1770,60,1830,35990,521855,5949147,55525372,436270780,2944827765,17341763505,90177170226,418094152866,1742058970275,6566222272575,22512762077400,70539987842520,202802465047245,536830054536827,1312251244423348,2969831763694961,6236646703759430,12176310231149294,22138745874816844,37539612570341496,59437719903041570,87967825456500510,121801604478232050,157890968768078200,191724747789809020,218169540588404700,232714176627628350,232714176627628350,218169540588404700,191724747789809020,157890968768078200,121801604478232050,87967825456500510,59437719903041570,37539612570341496,22138745874816844,12176310231149294,6236646703759430,2969831763694961,1312251244423348,536830054536827,202802465047245,70539987842520,22512762077400,6566222272575,1742058970275,418094152866,90177170226,17341763505,2944827765,436270780,55525372,5949147,521855,35990,1830,61,1891,37820,557845,6471002,61474519,491796152,3381098545,20286591270,107518933731,508271323092,2160153123141,8308281242850,29078984349975,93052749919920,273342452889764,739632519584073,1849081298960184,4282083008118307,9206478467454360,18412956934908750,34315056105966220,59678358445158720,96977332473382340,147405545359542900,209769429934734100,279692573246309900,349615716557889540,409894288378211140,450883717216037440,465428353255257600,450883717216037440,409894288378211140,349615716557889540,279692573246309900,209769429934734100,147405545359542900,96977332473382340,59678358445158720,34315056105966220,18412956934908750,9206478467454360,4282083008118307,1849081298960184,739632519584073,273342452889764,93052749919920,29078984349975,8308281242850,2160153123141,508271323092,107518933731,20286591270,3381098545,491796152,61474519,6471002,557845,37820,1891,62,1953,39711,595665,7028847,67945521,553270671,3872894697,23667689815,127805525001,615790256823,2668424446233,10468434365991,37387265592825,122131734269894,366395202809684,1012974972473834,2588713818544255,6131164307078520,13488561475572636,27619435402363012,52728013040875096,93993414551124600,156655690918540700,244382877832923170,357174975294275600,489462003181044900,629308289804196500,759510004936096900,860778005594245100,916312070471303300,916312070471303300,860778005594245100,759510004936096900,629308289804196500,489462003181044900,357174975294275600,244382877832923170,156655690918540700,93993414551124600,52728013040875096,27619435402363012,13488561475572636,6131164307078520,2588713818544255,1012974972473834,366395202809684,122131734269894,37387265592825,10468434365991,2668424446233,615790256823,127805525001,23667689815,3872894697,553270671,67945521,7028847,595665,39711,1953,63,2016,41664,635376,7624512,74974368,621216192,4426165368,27540584512,151473214816,743595781824,3284214703056,13136858812224,47855699958816,159518999862720,488526937079575,1379370175283509,3601688791018076,8719878125622774,19619725782651216,41107996877935830,80347448443237890,146721427591999840,250649105469665820,401038568751463550,601557853127192800,846636978475311400,1118770292985243800,1388818294740300500,1620288010530354400,1777090076065540900,1832624140942597000,1777090076065540900,1620288010530354400,1388818294740300500,1118770292985243800,846636978475311400,601557853127192800,401038568751463550,250649105469665820,146721427591999840,80347448443237890,41107996877935830,19619725782651216,8719878125622774,3601688791018076,1379370175283509,488526937079575,159518999862720,47855699958816,13136858812224,3284214703056,743595781824,151473214816,27540584512,4426165368,621216192,74974368,7624512,635376,41664,2016,64,2080,43680,677040,8259888,82598880,696190560,5047381560,31966749880,179013799328,895068996640,4027810484880,16421073515280,60992558771040,207374699821536,648045936942297,1867897112363079,4981058966301584,12321566916640794,28339603908274096,60727722660586830,121455445321173890,227068876035236400,397370533061665860,651687674221129000,1002596421878659800,1448194831602504700,1965407271460537600,2507588587725533000,3009106305270630000,3397378086595879400,3609714217008130600,3609714217008130600,3397378086595879400,3009106305270630000,2507588587725533000,1965407271460537600,1448194831602504700,1002596421878659800,651687674221129000,397370533061665860,227068876035236400,121455445321173890,60727722660586830,28339603908274096,12321566916640794,4981058966301584,1867897112363079,648045936942297,207374699821536,60992558771040,16421073515280,4027810484880,895068996640,179013799328,31966749880,5047381560,696190560,82598880,8259888,677040,43680,2080,65,2145,45760,720720,8936928,90858768,778789440,5743572120,37014131440,210980549208,1074082795968,4922879481520,20448884000160,77413632286320,268367258592577,855420636763833,2515943049305402,6848956078664654,17302625882942342,40661170824914420,89067326568860980,182183167981761340,348524321356407550,624439409096899100,1049058207282800900,1654284096099777300,2450791253481172000,3413602103063032300,4472995859186087000,5516694892996168000,6406484391866494000,7007092303603996000,7219428434016223000,7007092303603996000,6406484391866494000,5516694892996168000,4472995859186087000,3413602103063032300,2450791253481172000,1654284096099777300,1049058207282800900,624439409096899100,348524321356407550,182183167981761340,89067326568860980,40661170824914420,17302625882942342,6848956078664654,2515943049305402,855420636763833,268367258592577,77413632286320,20448884000160,4922879481520,1074082795968,210980549208,37014131440,5743572120,778789440,90858768,8936928,720720,45760,2145,66]
    // utils
    ,random = Math.random, round = Math.round, ceil = Math.ceil
    ,floor = Math.floor, exp = Math.exp, log = Math.log, pow = Math.pow
    ,min = Math.min, max = Math.max
    ,log2 = Math.log2 || function(x) { return Math.log(x) / Math.LN2; }
    ,rnd = function( m, M ) { return round( (M-m)*random() + m ); }
    ,EULER = Math.E
    ,clamp = function clamp( v, m, M ) { return ( v < m ) ? m : ((v > M) ? M : v); }
    ,summation = function(s, a) { return s+a }
    ,array = function( n ) { return new Array(n); }
    ,n_array = function n_array( dims ) {
        var len = dims.shift( ),
            a = len ? new Array( len ) : [ ], i
        ;
        if ( dims.length )
        {
            for (i=0; i<len; i++) a[ i ] = n_array( dims.slice(0) );
        }
        return a;
    }
    ,range = function range( n, options )  {
        var a, i;
        options = options || {};
        a = new Array( n );
        if ( options[HAS]('value') )
        {
            var v = options.value, is_arr_str = !!v.slice;
            for (i=0; i<n; i++) {a[ i ] = is_arr_str ? v.slice() : v;}
        }
        else
        {
            var start = options[HAS]('start') ? parseInt(options.start, 10) : 0,
                step = options[HAS]('step') ? parseInt(options.step, 10) : 1,
                istep = 0;
            for (i=0; i<n; i++) {a[ i ] = istep+start; istep += step;}
        }
        return a;
    }
    // http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
    // https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#Sattolo.27s_algorithm
    ,shuffle = function shuffle( a, cyclic, copied ) {
        var N, perm, swap, ac, offset;
        ac = true === copied ? a.slice() : a;
        offset = true === cyclic ? 1 : 0;
        N = ac.length;
        while ( offset < N-- )
        { 
            perm = rnd( 0, N-offset ); 
            if ( N === perm ) continue;
            swap = ac[ N ]; 
            ac[ N ] = ac[ perm ]; 
            ac[ perm ] = swap; 
        }
        // in-place or copy
        return ac;
    }
    // http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
    // eXtended shuffle variation to shuffle only parts of array
    // while leaving other parts unaltered
    ,xshuffle = function xshuffle( a, o, copied ) {
        var i, j, N, perm, swap, inc, ac, offset;
        ac = true === copied ? a.slice() : a;
        o = o || {};
        offset = true === o.cyclic ? 1 : 0;
        if ( o[HAS]('included') && o.included.length )
        {
            inc = o.included;
        }
        else if ( o[HAS]('included_range') && o.included_range.length )
        {
            inc = []; i=0; j=0;
            while (i < a.length)
            {
                if (j<o.included_range.length && (i>=o.included_range[j] && (j+1 >=o.included_range.length || i<=o.included_range[j+1]))) inc.push( i );
                else j+=2;
                i++;
            }
        }
        else if ( o[HAS]('excluded') && o.excluded.length )
        {
            inc = []; i=0; j=0;
            while (i < a.length)
            {
                if (j>=o.excluded.length || i<o.excluded[j]) inc.push( i );
                else j++;
                i++;
            }
        }
        else if ( o[HAS]('excluded_range') && o.excluded_range.length )
        {
            inc = []; i=0; j=0;
            while (i < a.length)
            {
                if (j<o.excluded_range.length && i>=o.excluded_range[j]) {i = j+1<o.excluded_range.length ? o.excluded_range[j+1] : i; j+=2;}
                else inc.push( i );
                i++;
            }
        }
        else
        {
            inc = [];
        }
        N = inc.length;
        while ( offset < N-- )
        { 
            perm = rnd( 0, N-offset ); 
            if ( N === perm ) continue;
            swap = ac[ inc[N] ]; 
            ac[ inc[N] ] = ac[ inc[perm] ]; 
            ac[ inc[perm] ] = swap; 
        }
        // in-place or copy
        return ac;
    }
    // Array multi - sorter utility
    // returns a sorter that can (sub-)sort by multiple (nested) fields 
    // each ascending or descending independantly
    // https://github.com/foo123/sinful.js
    ,sorter = function () {

        var arr = this, i, args = arguments, l = args.length,
            a, b, step, lt, gt,
            field, filter_args, sorter_args, desc, dir, sorter,
            ASC = '|^', DESC = '|v';
        // |^ after a (nested) field indicates ascending sorting (default), 
        // example "a.b.c|^"
        // |v after a (nested) field indicates descending sorting, 
        // example "b.c.d|v"
        if ( l )
        {
            step = 1;
            sorter = [];
            sorter_args = [];
            filter_args = []; 
            for (i=l-1; i>=0; i--)
            {
                field = args[i];
                // if is array, it contains a filter function as well
                filter_args.unshift('f'+i);
                if ( field.push )
                {
                    sorter_args.unshift(field[1]);
                    field = field[0];
                }
                else
                {
                    sorter_args.unshift(null);
                }
                dir = field.slice(-2);
                if ( DESC === dir ) 
                {
                    desc = true;
                    field = field.slice(0,-2);
                }
                else if ( ASC === dir )
                {
                    desc = false;
                    field = field.slice(0,-2);
                }
                else
                {
                    // default ASC
                    desc = false;
                }
                field = field.length ? '["' + field.split('.').join('"]["') + '"]' : '';
                a = "a"+field; b = "b"+field;
                if ( sorter_args[0] ) 
                {
                    a = filter_args[0] + '(' + a + ')';
                    b = filter_args[0] + '(' + b + ')';
                }
                lt = desc ?(''+step):('-'+step); gt = desc ?('-'+step):(''+step);
                sorter.unshift("("+a+" < "+b+" ? "+lt+" : ("+a+" > "+b+" ? "+gt+" : 0))");
                step <<= 1;
            }
            // use optional custom filters as well
            return (new Function(
                    filter_args.join(','), 
                    'return function(a,b) { return ('+sorter.join(' + ')+'); };'
                    ))
                    .apply(null, sorter_args);
        }
        else
        {
            a = "a"; b = "b"; lt = '-1'; gt = '1';
            sorter = ""+a+" < "+b+" ? "+lt+" : ("+a+" > "+b+" ? "+gt+" : 0)";
            return new Function("a,b", 'return ('+sorter+');');
        }
    }
    ,sum = function sum( arr ) {
        var s = 0, i, l = arr.length;
        for (i=0; i<l; i++) s += arr[i];
        return s;
    }
    ,intersection = function intersect_sorted2( a, b ) {
        var ai = 0, bi = 0, intersection = [ ],
            al = a.length, bl = b.length;
        // assume a, b lists are sorted ascending
        while( ai < al && bi < bl )
        {
            if      ( a[ai] < b[bi] )
            { 
                ai++; 
            }
            else if ( a[ai] > b[bi] )
            { 
                bi++; 
            }
            else // they're equal
            {
                intersection.push( a[ ai ] );
                ai++; bi++;
            }
        }
        return intersection;
    }
    ,union = function merge_unique_sorted2( a, b ) {
        var ai = 0, bi = 0, merged = [ ], last,
            al = a.length, bl = b.length;
        // assume a, b lists are sorted ascending 
        // <DEL>and each one does NOT contain duplicates</DEL>
        while( ai < al && bi < bl )
        {
            if      (merged.length) // handle any possible duplicates inside SAME list
            {
                if (a[ai] === last)
                {
                    ai++; continue;
                }
                else if (b[bi] === last)
                {
                    bi++; continue;
                }
            }
            if      ( a[ai] < b[bi] )
            { 
                merged.push( last=a[ai++] ); 
            }
            else if ( a[ai] > b[bi] )
            { 
                merged.push( last=b[bi++] ); 
            }
            else // they're equal, push one unique
            {
                merged.push( last=a[ ai ] );
                ai++; bi++;
            }
        }
        while ( ai < al ) if (a[ai++] !== last) merged.push( last=a[ai-1] ); 
        while ( bi < bl ) if (b[bi++] !== last) merged.push( last=b[bi-1] ); 
        return merged;
    }
    ,cycle2swaps = function( cycle ) {
        var swaps = [], c = cycle.length, j;
        if ( c > 1 ) for (j=c-1; j>=1; j--) swaps.push([cycle[0],cycle[j]])
        return swaps;
    }
    ,partition2cycles = function( partition ) {
        var cycles = [], cycle, i,
            pi, pl = partition.length, p,
            current = 0;
        for (pi=0; pi<pl; pi++)
        {
            p = partition[pi];
            cycle = new Array( p );
            // lexicographic cycle(s)
            for (i=0; i<p; i++) cycle[i] = current++;
            cycles.push(cycle);
        }
        return cycles;
    }
    ,factorial = function( n ) {
        var Fn;
        if ( 0 > n ) 
        {
            Fn = 0;
        }
        else if ( 2 > n ) 
        {
            Fn = 1;
        }
        else if ( 4 > n ) 
        {
            Fn = n*(n-1);
        }
        else if ( 68 > n ) 
        {
            // use fast pre-computed lookup table
            Fn = FACT_N_4_68[ n-4 ];
        }
        else
        {
            // compute it directly
            // use logarithmic sums to avoid overflows etc..
            var logFn = 0;
            while ( n > 1 ) logFn += log(n--);
            Fn = floor(0.5+exp(logFn));
        }
        return Fn;
    }
    // http://en.wikipedia.org/wiki/Derangement
    ,subfactorial = function( n ) {
        return floor(0.5 + factorial( n )/EULER);
    }
    // http://en.wikipedia.org/wiki/Binomial_coefficient
    ,binomial = function( n, k ) {
        var Cnk;
        k = min(k, n - k); // take advantage of symmetry
        if ( 0 > k || 1 > n ) 
        {
            Cnk = 0;
        }
        else if ( 0 === k || 1 === n ) 
        {
            Cnk = 1;
        }
        else if ( 1 === k ) 
        {
            Cnk = n;
        }
        else if ( 67 > n ) 
        {
            // use fast pre-computed lookup table
            Cnk = BINOM_N_K_3_67[ ((n-3)*(n-2)>>>1) + k-2 ];
        }
        else
        {
            // compute it directly
            // use logarithmic sums to avoid overflows etc..
            var logCnk = 0, i;
            for (i=0; i<k; i++) logCnk += log(n - i) - log(k - i);
            Cnk = floor(0.5+exp(logCnk));
        }
        return Cnk;
    }
    ,pow2 = function( n ) {
        return (1 << n)>>>0;
    }
    ,powNK = function( n, k ) {
        return pow(n, k);
    }
     // fast binary bitwise logarithm (most significant bit)
    ,log2msb = function( x ) {
        // assume x is 32-bit unsigned integer
        if ( 0 === x ) return -1;
        return 0xFFFF0000&x?(0xFF000000&x?24+BINLOG_256[x>>>24]:16+BINLOG_256[x>>>16]):(0x0000FF00&x?8+BINLOG_256[x>>>8]:BINLOG_256[x/*&0xFF*/]);
    }
    // recursively compute the partition count using the recursive relation:
    // http://en.wikipedia.org/wiki/Partition_(number_theory)#Partition_function
    // http://www.programminglogic.com/integer-partition-algorithm/
    ,partitions = function partitions( n, k, m ) {
        // compute number of integer partitions of n
        // into exactly k parts
        // having m as max value
        // m + k-1 <= n <= k*m
        if ( m === n && 1 === k ) return 1;
        if ( m+k>n+1 || k*m<n ) return 0;
        var j, jmax=min(m,n-m-k+2), jmin=max(1,ceil((n-m)/(k-1))), p = 0;
        for (j=jmin; j<=jmax; j++) p += partitions( n-m, k-1, j );
        return p;
    }
;

var Abacus = {
    VERSION: "0.1"
    
    ,random: random
    
    ,random_int: rnd
    
    ,clamp: clamp
    
    ,array: array

    ,range: range

    ,n_array: n_array

    ,sorter: sorter
    
    ,sum: sum
    
    ,intersection: intersection
    
    ,union: union
};

// Abacus.CombinatorialIterator, Combinatorial Base Class and Iterator Interface
var CombinatorialIterator = Abacus.CombinatorialIterator = Class({
    
    constructor: function CombinatorialIterator( n, k ) {
        var self = this;
        if ( !(self instanceof CombinatorialIterator) ) return new CombinatorialIterator(n, k);
        self.$n = n||0; self.$k = k||0;
        self.$total = self.constructor.count( self.$n, self.$k );
        self.rewind( );
    }
    
    ,__static__: {
         count: function( n, k ) { return 0; }
        ,index: function( item, n, k ) { return -1; }
        ,item: function( index, n, k ) { return null; }
        ,adjacent: function( offset, item, n, k ) {
            if ( -1 !== offset && 1 !== offset ) offset = 1;
            return item ? this.item( this.index(item, n, k)+offset, n, k ) : null;
        }
    }
    
    ,$n: 0,$k: 0
    ,$init: null
    ,$total: 0
    ,$index: null
    ,$current: null
    ,$prev: false
    ,$next: false
    
    ,dispose: function( ) {
        var self = this;
        self.$n = null;
        self.$k = null;
        self.$init = null;
        self.$total = 0;
        self.$index = null;
        self.$current = null;
        self.$prev = false;
        self.$next = false;
        return self;
    }
    
    ,total: function( ) { return this.$total; }
    
    ,randomise: function( ) { return this; }
    
    ,first: function( ) { return this.$current; }
    
    ,rewind: function( ) {
        var self = this;
        self.$index = 0;
        self.$current = self.first( );
        self.$prev = false;
        self.$next = true;
        return self;
    }
    
    ,hasNext: function( ) { return this.$next; }
    
    ,next: function( ) {
        var self = this, item = self.constructor.item,
            current = self.$current;
        // compute next
        if ( self.$index+1 < self.$total ) 
        {
            self.$next = true;
            self.$current = item( ++self.$index, self.$n, self.$k );
        }
        else
        {
            self.$next = false;
        }
        return current;
    }
    
    ,last: function( ) { return this.$current; }
    
    ,forward: function( ) {
        var self = this;
        self.$index = self.$total-1;
        self.$current = self.last( ); 
        self.$prev = true;
        self.$next = false;
        return self;
    }
    
    ,hasPrev: function( ) { return this.$prev; }
    
    ,prev: function( ) {
        var self = this, item = self.constructor.item,
            current = self.$current;
        // compute prev
        if ( self.$index-1 >= 0 ) 
        {
            self.$prev = true;
            self.$current = item( --self.$index, self.$n, self.$k );
        }
        else
        {
            self.$prev = false;
        }
        return current;
    }
    
    ,adjacent_next: function( ) {
        var self = this, 
            adjacent = self.constructor.adjacent, 
            item = self.$current;
        var next = adjacent(1, item, self.$n, self.$k);
        if ( !next ) 
        {
            self.$next = false;
        }
        else
        {            
            self.$current = next;
            self.$index++;
        }
        return item;
    }
    
    ,adjacent_prev: function( ) {
        var self = this, 
            adjacent = self.constructor.adjacent, 
            item = self.$current;
        var next = adjacent(-1, item, self.$n, self.$k);
        if ( !next ) 
        {
            self.$prev = false;
        }
        else
        {            
            self.$current = next;
            self.$index--;
        }
        return item;
    }
    
    ,random: function( ) {
        var self = this;
        return self.constructor.item( rnd(0, self.$total-1), self.$n, self.$k );
    }
    
    ,get: function( index ) {
        var self = this, item = self.constructor.item;
        if ( !arguments.length ) return self.$current;
        else if ( index >= 0 && index < self.$total ) return item( index, self.$n, self.$k );
        return null;
    }
    
    ,index: function( index ) {
        var self = this;
        if ( arguments.length )
        {
            if ( index >=0 && index < self.$total ) self.$index = index;
            return self;
        }
        return self.$index;
    }
    
    ,all: function( ) {
        var self = this, all = [];
        self.rewind();
        while ( self.hasNext() ) all.push( self.next() );
        return all;
    }
});

// https://en.wikipedia.org/wiki/Permutations
var Permutation = Abacus.Permutation = Class(CombinatorialIterator, {
    
    // extends and implements CombinatorialIterator
    constructor: function Permutation( n ) {
        var self = this, i;
        if ( !(self instanceof Permutation) ) return new Permutation(n);
        self.$init = new Array(n);
        for (i=0; i<n; i++) self.$init[i] = i;
        CombinatorialIterator.call(self, n);
    }
    
    ,__static__: {
         count: factorial
        // http://ldc.usb.ve/~bonet/reports/AAAI08-ws10-ranking.pdf
        // O(n log n) uniform lexicographic ranking.
        ,index: function( perm, n ) {
            var index = 0, i, j, node, ctr,
                k = ceil(log2(n)), Tl = (1<<(1+k))-1, 
                T = new Array(Tl), twok = 1<<k;
            for(i=0; i<Tl; i++) T[i] = 0;
            for(i=0; i<n; i++)
            {
                ctr = perm[i];
                node = twok + ctr;
                for(j=0; j<k; j++)
                {
                    if ( node&1 ) ctr = ctr - T[(node >>> 1) << 1];
                    T[node]++; node >>>= 1;
                }
                T[node]++;
                index = index * (n - i) + ctr;
            }
            return index;
        }
        // http://ldc.usb.ve/~bonet/reports/AAAI08-ws10-ranking.pdf
        // O(n log n) uniform lexicographic unranking.
        ,item: function( index, n ) {
            var perm = new Array(n), fn = factorial(n-1),
                i, j, i2, digit, node, rem,
                k = ceil(log2(n)), Tl = (1<<(1+k))-1,
                T = new Array(Tl), twok = 1<<k;
            
            for (i=0; i<=k; i++)
                for (j=1,i2=1<<i; j<=i2; j++) 
                    T[i2-1+j] = 1 << (k - i);
            
            rem = n-1;
            for (i=0; i<n; i++)
            {
                digit = ~~(index/fn); 
                node = 1;
                for (j=0; j<k; j++)
                {
                    T[node]--; node <<= 1;
                    if ( digit >= T[node] )
                    {
                        digit -= T[node];
                        node++;
                    }
                }
                T[node] = 0;
                perm[i] = node - twok;
                if ( rem )
                {
                    index %= fn; 
                    fn /= rem; 
                    rem--;
                }
            }
            return perm;
        }
        // http://en.wikipedia.org/wiki/Permutation#Systematic_generation_of_all_permutations
        ,adjacent: function( offset, item, n ) {
            if ( item )
            {
                var k, kl, l, r, s, next = item.slice( );
                
                if ( -1 === offset )
                {
                    //Find the largest index k such that a[k] > a[k + 1].
                    k = n-2;
                    while (k>=0 && next[k]<=next[k+1]) k--;
                    // If no such index exists, the permutation is the last permutation.
                    if ( k >=0 ) 
                    {
                        //Find the largest index kl greater than k such that a[k] > a[kl].
                        kl = n-1;
                        while (kl>k && next[k]<=next[kl]) kl--;
                        //Swap the value of a[k] with that of a[l].
                        s = next[k]; next[k] = next[kl]; next[kl] = s;
                        //Reverse the sequence from a[k + 1] up to and including the final element a[n].
                        l = k+1; r = n-1;
                        while (l < r) {s = next[l]; next[l++] = next[r]; next[r--] = s;}
                    }
                    else
                    {
                        next = null;
                    }
                }
                else //if ( 1 === offset )
                {
                    //Find the largest index k such that a[k] < a[k + 1].
                    k = n-2;
                    while (k>=0 && next[k]>=next[k+1]) k--;
                    // If no such index exists, the permutation is the last permutation.
                    if ( k >=0 ) 
                    {
                        //Find the largest index kl greater than k such that a[k] < a[kl].
                        kl = n-1;
                        while (kl>k && next[k]>=next[kl]) kl--;
                        //Swap the value of a[k] with that of a[l].
                        s = next[k]; next[k] = next[kl]; next[kl] = s;
                        //Reverse the sequence from a[k + 1] up to and including the final element a[n].
                        l = k+1; r = n-1;
                        while (l < r) {s = next[l]; next[l++] = next[r]; next[r--] = s;}
                    }
                    else
                    {
                        next = null;
                    }
                }
                return next;
            }
            return null;
        }
        ,inverse: function( perm, n ) {
            var i, iperm = new Array(n);
            for (i=0; i<n; i++) iperm[perm[i]] = i;
            return iperm;
        }
        ,toCycles: function( perm, n, strict ) {
            var i, cycles = [], current, cycle, 
                min_cycle = true === strict ? 1 : 0,
                visited = new Array( n ),
                unvisited = new Array(n);
            for(i=0; i<n; i++) 
            {
                unvisited[ i ] = i;
                visited[ i ] = 0;
            }
            cycle = [current = unvisited.shift( )]; visited[ current ] = 1;
            while ( unvisited.length ) 
            {
                current = perm[ current ];
                if ( visited[current] )
                {
                    if ( cycle.length > min_cycle ) cycles.push( cycle );
                    cycle = [ ];
                    while ( unvisited.length && visited[current=unvisited.shift()] ) ;
                }
                if ( !visited[current] )
                {
                    cycle.push( current );
                    visited[ current ] = 1; 
                }
            }
            if ( cycle.length > min_cycle ) cycles.push( cycle );
            return cycles;
        }
        ,fromCycles: function( cycles, n ) {
            var perm = new Array(n), c, l = cycles.length, i, cl, cycle;
            for (i=0; i<n; i++) perm[ i ] = i;
            for (c=0; c<l; c++)
            {
                cycle = cycles[c]; cl = cycle.length;
                if ( cl < 2 ) continue;
                for (i=0; i<cl-1; i++) perm[cycle[i]] = cycle[i+1];
                perm[cycle[cl-1]] = cycle[0];
            }
            return perm;
        }
        ,cycle2swaps: cycle2swaps
        ,toSwaps: function( perm, n ) {
            var i, l, swaps = [], cycle,
                cycles = Permutation.toCycles( perm, n, true );
            for (i=0,l=cycles.length; i<l; i++)
            {
                cycle = cycles[i];
                swaps = swaps.concat( cycle2swaps( cycle ) );
            }
            return swaps;
        }
        ,fromSwaps: function( swaps, n ) {
            var i, l = swaps.length, perm = new Array(n), swap, temp;
            for (i=0; i<n; i++) perm[i] = i;
            for (i=0; i<l; i++)
            {
                swap = swaps[i];
                // swap
                temp = perm[swap[0]]; 
                perm[swap[0]] = perm[swap[1]];
                perm[swap[1]] = temp;
            }
            return perm;
        }
        ,toMatrix: function( perm, n, bycolumns ) {
            var mat = new Array(n), i, j;
            bycolumns = true === bycolumns;
            for (i=0; i<n; i++)
            {
                mat[i] = new Array(n);
                for (j=0; j<n; j++) mat[i][j] = 0;
            }
            for (i=0; i<n; i++)
            {
                if ( bycolumns ) mat[perm[i]][i] = 1;
                else mat[i][perm[i]] = 1;
            }
            return mat;
        }
        ,fromMatrix: function( mat, n, bycolumns ) {
            var perm = new Array(n), i, j;
            bycolumns = true === bycolumns;
            for (i=0; i<n; i++)
            {
                for (j=0; j<n; j++)
                {
                    if ( mat[i][j] ) 
                    {
                        if ( bycolumns ) perm[j] = i;
                        else perm[i] = j;
                    }
                }
            }
            return perm;
        }
        ,reassign: function( arr, perm ) {
            var i, l = arr.length, reassigned = new Array(l);
            for (i=0; i<l; i++) reassigned[i] = perm[arr[i]];
            return reassigned;
        }
        ,permute: function( arr, perm, copied ) {
            var i, l = arr.length, p, a;
            if ( true === copied )
            {
                p = new Array(l);
                a = arr;
            }
            else
            {
                p = arr;
                a = arr.slice();
            }
            for (i=0; i<l; i++) p[i] = a[perm[i]];
            return p;
        }
        ,shuffle: shuffle
        ,xshuffle: xshuffle
    }
    
    ,first: function( ) {
        var self = this;
        return self.$init.slice( );
    }
    
    ,last: function( ) {
        var self = this;
        return self.$init.slice( ).reverse( );
    }
    
    ,next: CombinatorialIterator[PROTO].adjacent_next
    
    ,prev: CombinatorialIterator[PROTO].adjacent_prev
    
    ,random: function( ) {
        return shuffle(this.$init, false, true);
    }
});

// http://en.wikipedia.org/wiki/Derangement
var Derangement = Abacus.Derangement = Class(CombinatorialIterator, {
    
    // extends and implements CombinatorialIterator
    constructor: function Derangement( n ) {
        var self = this, i;
        if ( !(self instanceof Derangement) ) return new Derangement(n);
        CombinatorialIterator.call(self, n);
    }
    
    ,__static__: {
         count: subfactorial
        ,index: CombinatorialIterator.index
        ,item: CombinatorialIterator.item
        ,adjacent: CombinatorialIterator.adjacent
    }
});

// https://en.wikipedia.org/wiki/Combinations
var Combination = Abacus.Combination = Class(CombinatorialIterator, {
    
    // extends and implements CombinatorialIterator
    constructor: function Combination( n, k ) {
        var self = this, i;
        if ( !(self instanceof Combination) ) return new Combination(n, k);
        CombinatorialIterator.call(self, n, k);
    }
    
    ,__static__: {
         count: binomial
        ,index: function( item, n, k ) {
            var index = 0, i, c, j, 
                Cnk = binomial(n, k);
            for (i=1; i<=k; i++)
            {
                // adjust the order to match MSB to LSB 
                // reverse of wikipedia article http://en.wikipedia.org/wiki/Combinatorial_number_system
                c = n-1-item[i-1]; j = k+1-i;
                index += j<=c?binomial(c, j):0;
            }
            return Cnk-1-index;
        }
        ,item: function( index, n, k ) {
            var item = new Array(k), i, j, cnk, cnk2, Bnk, m;
            //index = n_k-1-index;
            for (i=k; i>=1; i--)
            {
                if ( index > 0 )
                {
                    m = i-1; j = i;
                    cnk2 = cnk = binomial(m, j);
                    while ( cnk2 <= index )
                    {
                        m++; cnk = cnk2;
                        // use recursion relations to avoid recomputing binomial
                        cnk2 = m > j ? m*cnk/(m-j) : 1;
                    }
                    item[i-1] = m-1;
                    index -= cnk;
                }
                else
                {
                    item[i-1] = i-1;
                }
            }
            return item;
        }
        ,adjacent: function( offset, item, n, k ) {
            if ( item )
            {
                var i, index, limit, curr, next = item.slice();
                
                if ( -1 === offset )
                {
                    // compute prev indexes
                    // find index to move
                    i = k-1;  index = -1; limit = n-k;
                    while ( 0 <= i )
                    {
                        if ( next[i] > i ) { index = i; break; }
                        i--;
                    }
                    // adjust next indexes after the moved index
                    if ( -1 < index )
                    {
                        curr = next[k-1];
                        for (i=k-1; i>=index; i--) next[i] = --curr;
                    }
                    else 
                    { 
                        next = null; 
                    }
                }
                else //if ( 1 === offset )
                {
                    // compute next indexes
                    // find index to move
                    i = k-1;  index = -1; limit = n-k;
                    while ( 0 <= i )
                    {
                        if ( next[i] < limit+i ) { index = i; break; }
                        i--;
                    }
                    // adjust next indexes after the moved index
                    if ( -1 < index )
                    {
                        curr = next[index];
                        for (i=index; i<k; i++) next[i] = ++curr;
                    }
                    else 
                    { 
                        next = null; 
                    }
                }
                return next;
            }
            return null;
        }
        ,complement: function( comb, n, k ) {
            var i, i1 = 0, i2 = 0, comp = new Array(n-k);
            for (i=0; i<n; i++)
            {
                if (i1>=k || i<comb[i1]) comp[i2++] = i;
                else i1++;
            }
            return comp;
        }
        ,choose: function( arr, comb ) {
            var i, l = comb.length, chosen = new Array(l);
            for (i=0; i<l; i++) chosen[i] = arr[comb[i]];
            return chosen;
        }
        ,toMatrix: function( comb, n, k, bycolumns ) {
            var mat = new Array(n), i, j;
            bycolumns = true === bycolumns;
            for (i=0; i<n; i++)
            {
                mat[i] = new Array(n);
                for (j=0; j<n; j++) mat[i][j] = 0;
            }
            for (i=0; i<k; i++)
            {
                if ( bycolumns ) mat[comb[i]][i] = 1;
                else mat[i][comb[i]] = 1;
            }
            return mat;
        }
        ,fromMatrix: function( mat, n, k, bycolumns ) {
            var comb = new Array(k), i, j;
            bycolumns = true === bycolumns;
            for (i=0; i<n; i++)
            {
                for (j=0; j<n; j++)
                {
                    if ( mat[i][j] ) 
                    {
                        if ( bycolumns && j < k ) comb[j] = i;
                        else if ( !bycolumns && i < k ) comb[i] = j;
                    }
                }
            }
            return comb;
        }
    }
    
    ,first: function( ) {
        var self = this, i, k = self.$k, n = self.$n, item = new Array(k);
        for (i=0; i<k; i++) item[i] = i;
        return item;
    }
    
    ,last: function( ) {
        var self = this, i, k = self.$k, n = self.$n, 
            item = new Array(k), n_k = n-k-1;
        for (i=0; i<k; i++) item[i] = n_k+i;
        return item;
    }
    
    ,next: CombinatorialIterator[PROTO].adjacent_next
    
    ,prev: CombinatorialIterator[PROTO].adjacent_prev
    
    ,random: function( ) {
        var self = this, n = self.$n, k = self.$k,
            combination = new Array(k), m, M, i, index;
        i = k; m = 0; M = k-1;
        while ( 0 < i-- ) 
        { 
            index = rnd(m, M); 
            combination[k-i-1] = index; 
            m = index+1;  M = (M<n-1)?M+1:M; 
        }
        return combination;
    }
});
// aliases
Combination.conjugate = Combination.complement;

var CombinationRepeat = Abacus.CombinationRepeat = Class(CombinatorialIterator, {
    
    // extends and implements CombinatorialIterator
    constructor: function CombinationRepeat( n, k ) {
        var self = this, i;
        if ( !(self instanceof CombinationRepeat) ) return new CombinationRepeat(n, k);
        CombinatorialIterator.call(self, n, k);
    }
    
    ,__static__: {
         count: powNK
        ,index: CombinatorialIterator.index
        ,item: CombinatorialIterator.item
        ,adjacent: function( offset, item, n, k ) {
            if ( item )
            {
                var i, index, limit, curr, next = item.slice();
                
                if ( -1 === offset )
                {
                    // compute prev indexes
                    // find index to move
                    i = k-1;  index = -1;
                    while (0 <= i)
                    {
                        if ( next[i] < n-1 ) {  index=i; break; }
                        i--;
                    }
                    // adjust next indexes after the moved index
                    if (-1 < index)
                    {
                        curr = next[index]+1;
                        for (i=index; i<k; i++) next[i] = curr;
                    }
                    else 
                    { 
                        next = null; 
                    }
                }
                else //if ( 1 === offset )
                {
                    // compute next indexes
                    // find index to move
                    i = k-1;  index = -1;
                    while (0 <= i)
                    {
                        if ( next[i] < n-1 ) {  index=i; break; }
                        i--;
                    }
                    // adjust next indexes after the moved index
                    if (-1 < index)
                    {
                        curr = next[index]+1;
                        for (i=index; i<k; i++) next[i] = curr;
                    }
                    else 
                    { 
                        next = null; 
                    }
                }
                return next;
            }
            return null;
        }
    }
    
    ,first: function( ) {
        var self = this, i, k = self.$k, n = self.$n, item = new Array(k);
        for (i=0; i<k; i++) item[i] = 0;
        return item;
    }
    
    ,last: function( ) {
        var self = this, i, k = self.$k, n = self.$n, 
            item = new Array(k);
        for (i=0; i<k; i++) item[i] = n-1;
        return item;
    }
    
    ,next: CombinatorialIterator[PROTO].adjacent_next
    
    ,prev: CombinatorialIterator[PROTO].adjacent_prev
    
    ,random: function( ) {
        var self = this, n = self.$n, k = self.$k,
            combination = new Array(k), m, M, i, index;
        m=0;  M=n-1;
        for (i=0; i<k; i++)
        { 
            index = rnd(m, M); 
            combination[i] = index; 
            m = index; 
        }
        return combination;
    }
});

// https://en.wikipedia.org/wiki/Partitions
var Partition = Abacus.Partition = Class(CombinatorialIterator, {
    
    // extends and implements CombinatorialIterator
    constructor: function Partition( n ) {
        var self = this;
        if ( !(self instanceof Partition) ) return new Partition(n);
        CombinatorialIterator.call(self, n);
    }
    
    ,__static__: {
         count: function( n ) {
             var p = n > 1 ? 2 : 1, k, m;
             for (k=2; k<n; k++) 
                 for (m=n-k+1; m>=1; m--)
                    p += partitions(n, k, m);
             return p;
         }
        // http://www.artofproblemsolving.com/wiki/index.php/Partition_%28combinatorics%29
        // http://mathworld.wolfram.com/ConjugatePartition.html
        ,conjugate: function( partition ) {
            var l = partition.length, 
                n = partition[0], i, j, p,
                conjugate = new Array(n);
            for (i=0; i<n; i++) conjugate[ i ] = 1;
            for (j=1; j<l; j++)
            {
                i = 0; p = partition[j];
                while ( i < n && p > 0 )
                {
                    conjugate[i++]++;
                    p--;
                }
            }
            return conjugate;
        }
        ,pack: function( partition ) {
            var packed = [], i, l = partition.length, 
                last = partition[0], part = [last, 1];
            for (i=1; i<l; i++)
            {
                if ( last === partition[i] ) part[1]++;
                else
                {
                    packed.push(part);
                    last = partition[i];
                    part = [last, 1];
                }
            }
            packed.push(part);
            return packed;
        }
        ,unpack: function( packed ) {
            var partition = [], i, j, k, v, l = packed.length, cmp;
            for (i=0; i<l; i++)
            {
                cmp = packed[i];
                if (1 === cmp[1] ) partition.push(cmp[0]);
                else
                {
                    k = cmp[1]; v = cmp[0];
                    for(j=0; j<k; j++) partition.push(v);
                }
            }
            return partition;
        }
        ,toCycles: partition2cycles
        ,index: CombinatorialIterator.index
        ,item: CombinatorialIterator.item
        ,adjacent: function( offset, item, n ) {
            if ( item )
            {
                var i, c, p1, p2, sum, rem, 
                    next = item.slice( );
                
                if ( -1 === offset )
                {
                    // compute prev partition
                    if ( next[0] < n )
                    {
                        c = next.length;
                        sum = new Array(c);
                        for (i=0; i<c; i++) sum[i] = next[i] + (i?sum[i-1]:0);
                        i = c-1;
                        while ( i>0 && next[i] === next[i-1] ) i--;
                        if ( i > 0 && 1+sum[i] > num ) i--;
                        next[i]++;
                        next = next.slice(0, i+1);
                        sum = next.reduce(summation, 0);
                        rem = n-sum;
                        while ( rem > 0 )
                        {
                            next.push(1);
                            rem--;
                        }
                    }
                    // if partition is the number itself it is the final partition
                    else 
                    { 
                        next = null; 
                    }
                }
                else //if ( 1 === offset )
                {
                    // compute next partition
                    if ( next[0] > 1 )
                    {
                        c = next.length;
                        // break into a partition with last part reduced by 1 from previous partition series
                        i = c-1;
                        while (i>=0 && 1 === next[i]) i--;
                        p1 = next[i]-1;
                        next = next.slice(0, i+1);
                        next[ i ] = p1;
                        sum = next.reduce(summation, 0);
                        rem = n-sum;
                        while ( rem > 0 )
                        {
                            p2 = rem;
                            if ( p2 > p1 ) 
                            { 
                                p2 = p1;  
                                next.push(p2); 
                            }
                            else 
                            { 
                                next.push(rem); 
                            }
                            rem -= p2;
                        }
                    }
                    // if partition is all ones (so first element is also one) it is the final partition
                    else 
                    { 
                        next = null; 
                    }
                }
                return next;
            }
            return null;
        }
    }
    
    ,first: function( ) {
        var self = this;
        return [ self.$n ]; 
    }
    
    ,last: function( ) {
        var self = this, i, n = self.$n, item = new Array(n); 
        for (i=0; i<n; i++) item[i] = 1;
        return item;
    }
    
    ,next: CombinatorialIterator[PROTO].adjacent_next
    
    ,prev: CombinatorialIterator[PROTO].adjacent_prev
    
    ,random: function( ) {
        var self = this, n = self.$n, tot = self.$total, p,
            parts, nparts = rnd(1, n/*tot*/), partition
        ;
        
        // try to generate partitions that sample uniformly the combinatorial object space
        // i.e. every possible partition is equi-likely to be output (NEEDS CHECK) 
        if ( 1 === nparts ) 
        {  
            partition = [n]; 
        }
        else if ( n === nparts ) 
        { 
            partition = new Array(n);
            for (p=0; p<n; p++) partition[p] = 1;
        }
        else
        {
            parts = new Array(n);
            while ( nparts > 1 )
            {
                p = rnd(1, n-nparts+1);
                if ( !parts[p-1] ) parts[p-1] = [p];
                else parts[p-1].push(p);
                n -= p; 
                nparts--;
            }
            if ( !parts[n-1] ) parts[n-1] = [n];
            else parts[n-1].push(n);
            partition = [ ];
            for (p=parts.length-1; p>=0; p--) if ( parts[p] ) partition = partition.concat(parts[p]);
        }
        return partition;
    }
});
// aliases
Partition.transpose = Partition.conjugate;

var RestrictedPartition = Abacus.RestrictedPartition = Class(CombinatorialIterator, {
    
    // extends and implements CombinatorialIterator
    constructor: function RestrictedPartition( n, k, m ) {
        var self = this, i;
        if ( !(self instanceof RestrictedPartition) ) return new RestrictedPartition(n, k, m);
        self.$m = m;
        CombinatorialIterator.call(self, n, k);
    }
    
    ,__static__: {
         count: partitions
        ,index: CombinatorialIterator.index
        ,item: CombinatorialIterator.item
        ,adjacent: CombinatorialIterator.adjacent
    }
});

// http://en.wikipedia.org/wiki/Power_set
var PowerSet = Abacus.PowerSet = Class(CombinatorialIterator, {
    
    // extends and implements CombinatorialIterator
    constructor: function PowerSet( n ) {
        var self = this;
        if ( !(self instanceof PowerSet) ) return new PowerSet(n);
        CombinatorialIterator.call(self, n);
    }
    
    ,__static__: {
         count: pow2
        ,index: function( subset/*, n*/ ) { 
            var index = 0, i = 0, l = subset.length;
            while ( i < l ) index += (1<<subset[i++])>>>0;
            return index;
        }
        ,item: function( index/*, n*/ ) { 
            var subset = [], i, x = index>>>0;
            while ( 0 !== x )
            {
                subset.push( i=log2msb( x ) );
                x = (x & (~((1<<i)>>>0)>>>0))>>>0;
            }
            return subset;
        }
        ,adjacent: CombinatorialIterator.adjacent
    }
    
    ,first: function( ) {
        return [];
    }
    
    ,last: function( ) {
        var self = this, i, n = self.$n, item = new Array( n ); 
        for (i=0; i<n; i++) item[ i ] = i;
        return item;
    }
});

// export it
return Abacus;
});
